package devbrowser

import (
	"context"
	"testing"

	"github.com/mendes11/swarm-browser/internal/core/models"
	"github.com/moby/moby/api/types/swarm"
)

func TestDevBrowser(t *testing.T) {
	// Create a test config
	config := &DevConfig{
		Clusters: map[string]models.Cluster{
			"test-cluster": {
				Name: "Test Cluster",
				Node: models.Node{Host: "test.local"},
				Nodes: map[string]models.Node{
					"test-node-1": {Host: "test-node-1.local", Hostname: "test-node-1"},
					"test-node-2": {Host: "test-node-2.local", Hostname: "test-node-2"},
				},
			},
		},
		Stacks: []StackConfig{
			{
				Name:        "test-stack",
				ClusterName: "test-cluster",
				Services: []ServiceConfig{
					{
						ID:           "test-service-1",
						Name:         "service1",
						DesiredTasks: 3,
						RunningTasks: 2,
					},
					{
						ID:           "test-service-2",
						Name:         "service2",
						DesiredTasks: 1,
						RunningTasks: 1,
						Tasks: []TaskConfig{
							{
								ID:          "custom-task-1",
								ContainerID: "custom-container-1",
								NodeName:    "test-node-1",
								Status:      "running",
							},
						},
					},
				},
			},
		},
	}

	// Create browser with test config
	browser, err := NewWithConfig("test-cluster", config)
	if err != nil {
		t.Fatalf("NewWithConfig failed: %v", err)
	}
	defer browser.Close()

	ctx := context.Background()

	// Test GetCluster
	t.Run("GetCluster", func(t *testing.T) {
		cluster := browser.GetCluster()
		if cluster.Name != "Test Cluster" {
			t.Errorf("Expected cluster name 'Test Cluster', got '%s'", cluster.Name)
		}
		if len(cluster.Nodes) != 2 {
			t.Errorf("Expected 2 nodes, got %d", len(cluster.Nodes))
		}
	})

	// Test ListStacks
	t.Run("ListStacks", func(t *testing.T) {
		stacks, err := browser.ListStacks(ctx)
		if err != nil {
			t.Fatalf("ListStacks failed: %v", err)
		}
		if len(stacks) != 1 {
			t.Errorf("Expected 1 stack, got %d", len(stacks))
		}
		if stacks[0].Name != "test-stack" {
			t.Errorf("Expected stack name 'test-stack', got '%s'", stacks[0].Name)
		}
	})

	// Test ListServices
	t.Run("ListServices", func(t *testing.T) {
		stack := models.Stack{Name: "test-stack"}
		services, err := browser.ListServices(ctx, stack)
		if err != nil {
			t.Fatalf("ListServices failed: %v", err)
		}
		if len(services) != 2 {
			t.Errorf("Expected 2 services, got %d", len(services))
		}

		// Check first service
		if services[0].ID != "test-service-1" {
			t.Errorf("Expected service ID 'test-service-1', got '%s'", services[0].ID)
		}
		if services[0].DesiredTasks != 3 {
			t.Errorf("Expected 3 desired tasks, got %d", services[0].DesiredTasks)
		}
		if services[0].RunningTasks != 2 {
			t.Errorf("Expected 2 running tasks, got %d", services[0].RunningTasks)
		}
	})

	// Test ListTasks with auto-generated tasks
	t.Run("ListTasks_AutoGenerated", func(t *testing.T) {
		stack := models.Stack{Name: "test-stack"}
		service := models.Service{
			ID:           "test-service-1",
			Name:         "test-stack_service1",
			Stack:        stack,
			DesiredTasks: 3,
			RunningTasks: 2,
		}

		tasks, err := browser.ListTasks(ctx, service)
		if err != nil {
			t.Fatalf("ListTasks failed: %v", err)
		}
		if len(tasks) != 3 {
			t.Errorf("Expected 3 tasks, got %d", len(tasks))
		}

		// Check that we have 2 running and 1 pending/failed
		runningCount := 0
		for _, task := range tasks {
			if task.Status == swarm.TaskStateRunning {
				runningCount++
			}
		}
		if runningCount != 2 {
			t.Errorf("Expected 2 running tasks, got %d", runningCount)
		}
	})

	// Test ListTasks with custom tasks
	t.Run("ListTasks_Custom", func(t *testing.T) {
		stack := models.Stack{Name: "test-stack"}
		service := models.Service{
			ID:    "test-service-2",
			Name:  "test-stack_service2",
			Stack: stack,
		}

		tasks, err := browser.ListTasks(ctx, service)
		if err != nil {
			t.Fatalf("ListTasks failed: %v", err)
		}
		if len(tasks) != 1 {
			t.Errorf("Expected 1 task, got %d", len(tasks))
		}

		// Check custom task details
		if tasks[0].TaskID != "custom-task-1" {
			t.Errorf("Expected task ID 'custom-task-1', got '%s'", tasks[0].TaskID)
		}
		if tasks[0].ContainerID != "custom-container-1" {
			t.Errorf("Expected container ID 'custom-container-1', got '%s'", tasks[0].ContainerID)
		}
		if tasks[0].Status != swarm.TaskStateRunning {
			t.Errorf("Expected task status 'running', got '%v'", tasks[0].Status)
		}
		if tasks[0].Node.Hostname != "test-node-1" {
			t.Errorf("Expected task on node 'test-node-1', got '%s'", tasks[0].Node.Hostname)
		}
	})

	// Test AttachToService
	t.Run("AttachToService", func(t *testing.T) {
		stack := models.Stack{Name: "test-stack"}
		service := models.Service{
			ID:    "test-service-2",
			Name:  "test-stack_service2",
			Stack: stack,
		}

		// Test with echo command instead of interactive shell
		conn, err := browser.AttachToService(ctx, service, []string{"echo", "test"})
		if err != nil {
			t.Fatalf("AttachToService failed: %v", err)
		}
		defer conn.Close()

		// Verify connection was established
		if conn == nil {
			t.Error("Expected non-nil connection")
		}
	})

	// Test with non-existent stack
	t.Run("ListServices_NonExistent", func(t *testing.T) {
		stack := models.Stack{Name: "non-existent"}
		services, err := browser.ListServices(ctx, stack)
		if err != nil {
			t.Fatalf("ListServices failed: %v", err)
		}
		if len(services) != 0 {
			t.Errorf("Expected 0 services for non-existent stack, got %d", len(services))
		}
	})

	// Test with non-existent cluster
	t.Run("NewWithConfig_NonExistentCluster", func(t *testing.T) {
		_, err := NewWithConfig("non-existent", config)
		if err == nil {
			t.Error("Expected error for non-existent cluster")
		}
	})
}

func TestLoadConfig(t *testing.T) {
	// Test that config requires clusters and validates references
	t.Run("ValidateClusterReferences", func(t *testing.T) {
		config := &DevConfig{
			Clusters: map[string]models.Cluster{
				"cluster1": {
					Name: "Cluster 1",
					Node: models.Node{Host: "cluster1.local"},
					Nodes: map[string]models.Node{
						"node1": {Host: "node1.local", Hostname: "node1"},
					},
				},
			},
			Stacks: []StackConfig{
				{
					Name:        "stack1",
					ClusterName: "cluster1",
					Services: []ServiceConfig{
						{
							Name:         "service1",
							DesiredTasks: 1,
							RunningTasks: 1,
						},
					},
				},
			},
		}

		// This should work as cluster1 exists
		stacks := config.GetStacksForCluster("cluster1")
		if len(stacks) != 1 {
			t.Errorf("Expected 1 stack for cluster1, got %d", len(stacks))
		}

		// This should return empty for non-existent cluster
		stacks = config.GetStacksForCluster("non-existent")
		if len(stacks) != 0 {
			t.Errorf("Expected 0 stacks for non-existent cluster, got %d", len(stacks))
		}
	})
}

func TestParseTaskStatus(t *testing.T) {
	browser := &DevBrowser{}

	tests := []struct {
		input    string
		expected swarm.TaskState
	}{
		{"running", swarm.TaskStateRunning},
		{"pending", swarm.TaskStatePending},
		{"failed", swarm.TaskStateFailed},
		{"complete", swarm.TaskStateComplete},
		{"shutdown", swarm.TaskStateShutdown},
		{"rejected", swarm.TaskStateRejected},
		{"orphaned", swarm.TaskStateOrphaned},
		{"remove", swarm.TaskStateRemove},
		{"unknown", swarm.TaskStateRunning}, // Default case
	}

	for _, test := range tests {
		t.Run(test.input, func(t *testing.T) {
			result := browser.parseTaskStatus(test.input)
			if result != test.expected {
				t.Errorf("parseTaskStatus(%s) = %v, expected %v", test.input, result, test.expected)
			}
		})
	}
}

func TestGetNodeFromCluster(t *testing.T) {
	config := &DevConfig{
		Clusters: map[string]models.Cluster{
			"test": {
				Name: "Test",
				Node: models.Node{Host: "test.local"},
				Nodes: map[string]models.Node{
					"node1": {Host: "node1.local", Hostname: "node1"},
					"node2": {Host: "node2.local", Hostname: "node2"},
				},
			},
		},
	}

	// Test existing node
	node, exists := config.GetNodeFromCluster("test", "node1")
	if !exists {
		t.Error("Expected node1 to exist")
	}
	if node.Hostname != "node1" {
		t.Errorf("Expected hostname 'node1', got '%s'", node.Hostname)
	}

	// Test non-existent node
	_, exists = config.GetNodeFromCluster("test", "node3")
	if exists {
		t.Error("Expected node3 to not exist")
	}

	// Test non-existent cluster
	_, exists = config.GetNodeFromCluster("non-existent", "node1")
	if exists {
		t.Error("Expected node to not exist in non-existent cluster")
	}
}
